## EffectiveJava3

#### 序列化

> 优先选择 Java 序列化的替代方案
  * ```Java```序列化有一定的风险，虽然能够实现分布式对象但代价较大，如不可见的构造函数、```API```与实现之间模糊的界线，还可能出现正确性、性能、安全性和维护方面的问题。序列化的根本问题在于它的可攻击范围太大，难以维护且问题在不断增多，可以通过调用```ObjectInputStream```上的```readObject```方法反序列化对象，这个方法可以用来实例化类路径上实现```Serializable```接口的任何类型的对象，在反序列化字节流的过程中，此方法可以执行来自任何这些类型的代码，因此所有这些类型的代码都在攻击范围内。攻击范围可涉及```Java```平台库、第三方库和应用程序本身中的类。在反序列化过程中调用潜在危险活动的方法称为```gadget```，若不使用任何```gadget```，通过对需要长时间才能反序列化的短流进行反序列化发起拒绝服务攻击，这种流被称为反序列化炸弹。
  * ```Java```序列化的替代方案：
    * 永远不反序列化任何东西。
    * 使用跨平台结构数据表示，如```JSON```和```Protocal Buffers```。前者设计用于浏览器与服务器通信，后者设计用于服务器之间存储和交换数据化结构。```JSON```和```Protocal Buffers```最显著的区别是```JSON```基于文本，可读性好，```Protocal Buffers```是二进制，效率高，但也提供了一种文本表示```pbtxt```。
    * 对于遗留系统，不能完成避免```Java```序列化，最佳实践是永远不反序列化不可信的数据。
    * 若无法避免反序列化且不能保证反序列化数据的安全性，可以使用```Java9```中添加的对象反序列化筛选并将其移植，该工具运行指定一个过滤器，该过滤器在反序列化数据流之前应用于数据流，它在类粒度上运行，运行接受或拒绝某些类，在默认情况下拒绝其他类并接受假定安全的类列表（白名单）。

> 非常谨慎地实现 Serializable

> 考虑使用自定义的序列化形式

> 保护性的编写 readObject 方法

> 对于实例控制，枚举类型优于 readResolve

> 考虑用序列化代理代替序列化实例