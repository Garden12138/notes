## EffectiveJava3

#### 异常

> 只针对异常的情况下才使用异常
  * 通常编写数组循环时可能会使用到异常模式：
    ```
    try {
        int i = 0; 
        while ( true ) 
            range[i++].climb(); 
    } catch (ArrayIndexOutOfBoundsException e) {

    }
    ``` 
    这个循环试图在访问数组边界之外的第一个元素时使用```try-catch```捕获```ArrayIndexOutOfBoundsException```异常来达到终止无限循环的目的。与其等价的数组循环的正常模式：
    ```
    for (Mountain m : range)
        m.climb();
    ```
    使用异常模式认为利用```java```的错误判断机制来提高程序的性能，因为```VM```对每次数组访问都要检查越界情况。这种模式有三个错误认识：
      * 异常设计的初衷适用于不正常的情形，几乎没有```JVM```实现试图对它们进行优化，使它们与显式的测试一样快。
      * 将代码放置```try-catch```块反而阻止现代```JVM```实现本可能执行的某些特定优化。
      * 对数据进行遍历的标准模式并不会导致冗余检查。

    基于异常的循环模式不仅模糊代码意图，降低性能，而且还不能保证正常工作。若出现不相关缺陷，这个模式会掩盖缺陷，极大地增加了调试的复杂性。若使用正常的循环模式，在产生未被捕获的异常后导致线程立即结束并产生完整的堆栈信息。异常应该只用于异常的情况，不应该用于正常的程序控制流程。
  * 设计良好的```API```避免客户端为了正常的控制流程使用异常。若类中具有状态相关的方法（即只有在特定的不可预知的条件下才可被调用的方法），这个类应该也具有对应的状态测试方法（即表明是否可以调用这个状态相关的方法），如```Iterator```接口具有状态相关的```next```方法以及对应状态测试方法```hasNext```。另外一种提供单独状态测试的方法是返回零长度的```optional```值或者返回一个可被识别的返回值，如```nul```。这两种测试状态方法的选择：
    * 如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，则使用```optional```返回值或可识别的返回值。
    * 如果单独的状态测试方法必须重复状态相关方法的工作，从性能角度考虑，必须使用可识别的返回值。
    * 如果其他条件等同，则状态测试方法优于可识别的返回值。它提供了更高的可读性，更容易检测和更正。

> 对可恢复的情况使用受检异常，对编程错误使用运行时异常
  * ```Java```程序设计语言提供了三种```throwable```：受检异常（```checked exceptions```）、运行时异常（```runtime exceptions```）和错误（```errorrs```）。对于可恢复的情况，要抛出受检异常；对于程序错误，抛出运行时异常。不定义任何既不是受检异常也不是运行时异常的抛出类型。在受检异常上提供方法，以便协助程序恢复。

> 避免不必要的使用受检异常

> 优先使用标准的异常

> 抛出与抽象对应的异常

> 每个方法抛出的异常都需要创建文档

> 在细节消息中包含失败一捕获信息

> 保持失败原子性

> 不要忽略异常