## EffectiveJava3

#### 异常

> 只针对异常的情况下才使用异常
  * 通常编写数组循环时可能会使用到异常模式：
    ```
    try {
        int i = 0; 
        while ( true ) 
            range[i++].climb(); 
    } catch (ArrayIndexOutOfBoundsException e) {

    }
    ``` 
    这个循环试图在访问数组边界之外的第一个元素时使用```try-catch```捕获```ArrayIndexOutOfBoundsException```异常来达到终止无限循环的目的。与其等价的数组循环的正常模式：
    ```
    for (Mountain m : range)
        m.climb();
    ```
    使用异常模式认为利用```java```的错误判断机制来提高程序的性能，因为```VM```对每次数组访问都要检查越界情况。这种模式有三个错误认识：
      * 异常设计的初衷适用于不正常的情形，几乎没有```JVM```实现试图对它们进行优化，使它们与显式的测试一样快。
      * 将代码放置```try-catch```块反而阻止现代```JVM```实现本可能执行的某些特定优化。
      * 对数据进行遍历的标准模式并不会导致冗余检查。

    基于异常的循环模式不仅模糊代码意图，降低性能，而且还不能保证正常工作。若出现不相关缺陷，这个模式会掩盖缺陷，极大地增加了调试的复杂性。若使用正常的循环模式，在产生未被捕获的异常后导致线程立即结束并产生完整的堆栈信息。异常应该只用于异常的情况，不应该用于正常的程序控制流程。
  * 设计良好的```API```避免客户端为了正常的控制流程使用异常。若类中具有状态相关的方法（即只有在特定的不可预知的条件下才可被调用的方法），这个类应该也具有对应的状态测试方法（即表明是否可以调用这个状态相关的方法），如```Iterator```接口具有状态相关的```next```方法以及对应状态测试方法```hasNext```。另外一种提供单独状态测试的方法是返回零长度的```optional```值或者返回一个可被识别的返回值，如```nul```。这两种测试状态方法的选择：
    * 如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，则使用```optional```返回值或可识别的返回值。
    * 如果单独的状态测试方法必须重复状态相关方法的工作，从性能角度考虑，必须使用可识别的返回值。
    * 如果其他条件等同，则状态测试方法优于可识别的返回值。它提供了更高的可读性，更容易检测和更正。

> 对可恢复的情况使用受检异常，对编程错误使用运行时异常
  * ```Java```程序设计语言提供了三种```throwable```：受检异常（```checked exceptions```）、运行时异常（```runtime exceptions```）和错误（```errorrs```）。对于可恢复的情况，要抛出受检异常；对于程序错误，抛出运行时异常。不定义任何既不是受检异常也不是运行时异常的抛出类型。在受检异常上提供方法，以便协助程序恢复。

> 避免不必要的使用受检异常
  * 过分使用受检异常会使```API```使用不方便。如果方法抛出受检异常，调用该方法就必须在一个或多个```catch```块中处理这些异常。这种方法会带来编程负担，特别是```Java8```后，因为抛出受检异常的方法不能直接在```Stream```中使用。
    ```
    try {
        ...
    } catch(TheCheckedException e) {
        ...
    }
    ```
  * 若正确地使用```API```并不能阻止异常条件的产生，并且一旦发生异常，使用```API```的程序员可以根据获取的异常信息采取措施，此时需要使用受检异常。
  * 受检异常方法的替代方式：
    * 使用返回结果类型为```optional```，该方法不抛出受检异常，只返回一个零长度的```optional```。这种方法的缺点是，方法无法返回任何额外的信息。
    * 将抛出异常的方法分为两个方法，其中第一个方法返回一个布尔值，表明是否应该抛出异常，类似状态方法与其对应的状态测试方法。这种方法的缺点是对象在缺少外部同步的情况下被并发访问或可被外界改变状态时，第一个方法即状态测试方法就不安全：
      ```
      try{
          ...
          obj.action(args);
      } catch (TheCheckedException e) {
          ...
      }
      ```
      ```
      if (obj.actionPermitted(args)) {
          obj.action(args);
      } eles {
          ...
      }
      ```

> 优先使用标准的异常
  * ```Java```平台类库提供了一组基本的未受检异常，它们满足大多数```API```的异常抛出需求且可以被重用。重用标准异常的好处：
    * 它使```API```更容易学习和使用。
    * 对于使用这些```API```的程序而言，它们的可读性更好。
    * 异常类越少，意味着内存占用越小，装载这些类的时间开销也越少。
  * 常见的可重用异常：

    |异常|使用场合|
    |:------:|:------:|
    |IllegalArgumentException|非null的参数值不正确|
    |IllegalStateException|不适合方法调用的对象状态|
    |NullPointerException|在禁止使用null的情况下参数值为null|
    |IndexOutOfBoundsExecption|下标参数值越界|
    |ConcurrentModificationException|在禁止并发修改的情况下，检测到对象的并发修改|
    |UnsupportedOperationException|对象不支持用户请求的方法|

    选择重用异常并非总是精确的，如以一副牌的对线为例，假设有一个处理发牌操作的方法，它的参数是发一手牌的纸牌张数，假设调用者在这个参数传递的值大于整副纸牌的剩余张数，该情况既适用于```IllegalArgumentException```（```handSize```参数的值太大），也适用于```IllegalStateException```（纸牌对象包含的纸牌太少）。此时，若没有可用参数，则抛出
    ```IllegalStateException```，否则抛出```IllegalArgumentException```。

> 抛出与抽象对应的异常
  * 当方法传递由底层抽象抛出的异常时，高层的实现容易受到破坏，如果高层的实现在后续的发行版本中发生变化，它所抛出的异常也可能发生变化，从而潜在地破坏现有客户端程序。为了避免该问题，更高层的实现应该捕获底层抽象的异常，同时抛出可按高层进行解释的异常，这种做法称为异常转译：
    ```
    try {
        ...
    } catch (LowerLevelException e) {
        throw new HigherLevelException(...);
    }
    ```
  * 一种特殊的异常转译称为异常链，如果底层的异常可对于高层异常的调试提供帮助，适合使用异常链，底层的异常传递至高层的异常，高层的异常提供访问方法（```Throwable```的```getCause```方法）来获取底层的异常：
    ```
    try {
        ...
    } catch (LowerLevelException cause) {
        throw new HigherLevelException(cause);
    }
    ```
    ```
    public class HigherLevelException extends Exception {
        public HigherLevelException(Throwable cause) {
            super(cause);
        }
    }
    ```
  * 谨慎使用异常转译。如果可能，处理来自底层异常的最好做法是在调用底层方法之前确保它们成功执行，从而避免它们抛出异常。如果无法阻止来自底层的异常，则在高层处理这些异常，如记录机制（```log```）或在传递给底层参数之前，在高层实现处进行参数的有效性校验等。

> 每个方法抛出的异常都需要创建文档
  * 描述一个方法所抛出的异常，是正确使用这个方法时所需文档的重要组成部分。因此为每个方法所抛出的异常建立文档是有必要的。
  * 实例方法始终单独地声明受检异常（使用关键字```throws```），并且使用```Javadoc```的```@throws```标签，准确地记录抛出每个异常的条件。声明多个异常时不应该使用超类，如```throws Exception```（```main```方法除外）。对于未受检异常，可以将异常信息组织成列表文档，有效地描述出这个方法被成功执行的前提条件。
  * 接口方法需要在文档中记录它可能抛出的未受检异常，这份文档构成了接口的通用约定，它指定了实现该接口的多个实现必须遵循的公共行为。
  * 使用```Javadoc```的```@throws```标签记录方法可能抛出的每个未受检异常，但不能使用关键字```throws```在方法中声明未受检异常。为每个方法抛出的未受检异常建立文档是理想但非必需，若方法经常被修改，建立未受检异常文档则非必要。
  * 如果一个类的许多方法由于同样的原因抛出同一个异常，可在该类上对这个异常建立文档，如```NullPointerException```。

> 在细节消息中包含失败一捕获信息

> 保持失败原子性

> 不要忽略异常